<!DOCTYPE html>
<html>

<head>
    <title>three.js webgl - lines - splines</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            background-color: #ffffff;
            margin: 0px;
            overflow: hidden;
        }
        a {
            color: #0078ff;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            color: #ffffff;
            padding: 5px;
            font-family: Monospace;
            font-size: 13px;
            text-align: center;
            z-index: 100;
        }
        a {
            color: orange;
            text-decoration: none;
        }
        a:hover {
            color: #0080ff;
        }
    </style>
</head>

<body>

	<p id= "hoverText" style="display:none; padding:20%; padding:20%; position:absolute; font-family:'Courier New', Courier, monospace"> hello, here is some text </p> 
    <audio style= "display:none;" id="myAudio1" src = "Sand.wav" controls loop>
    <a href = "Sand.wav">DoYou.ogg</a>
  </audio>
  
  <audio style= "display:none;" id="myAudio2" src = "Skin.wav" controls loop>
    <a href = "Skin.wav">DoYou.ogg</a>
  </audio>
  
  <audio style= "display:none;" id="myAudio3" src = "whisper.wav" controls loop>
    <a href = "whisper.wav">DoYou.ogg</a>
  </audio>

    <script src="three.min.js"></script>

    <script src="hilbert3D.js"></script>
    <script src="Tween.js"></script>
    <script src="RequestAnimationFrame.js"></script>
    <script src="Detector.js"></script>
    <script src="stats.min.js"></script>
    <script src="PLYLoader.js"></script>
    <script src="//code.jquery.com/jquery-1.11.2.min.js"></script>
    <script src="//code.jquery.com/jquery-migrate-1.2.1.min.js"></script>
<!-- where curves formulas are defined -->
	<script src="CurveExtras.js"></script>

    <script>
        var xmlhttp = new XMLHttpRequest();
        var url = "johnLines.json";

        xmlhttp.onreadystatechange = function() {
            if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
                var myArr = JSON.parse(xmlhttp.responseText);

                init(myArr);
                animate();
            }
        }
        xmlhttp.open("GET", url, true);
        xmlhttp.send();
        if (!Detector.webgl) Detector.addGetWebGLMessage();

        var mouseX = 0,
            mouseY = 0,

            windowHalfX = window.innerWidth / 2,
            windowHalfY = window.innerHeight / 2,
            camera, cameraFollow,cameraFollowHelper, activeCamera, scene, renderer, material, raycaster, currentIntersected,
            arrayOfAllLines, count, currentlyBeingPlayed, scaledCurrentlyBeingPlayed, stopSetInterval, spherePlayHead, currentAudio;

		var allAudio = []; 
        var mouse = new THREE.Vector2();
        arrayOfAllLines = [];
		var isCameraMove; 
		var isLineFollowing; 
		var binormal = new THREE.Vector3();
		var normal = new THREE.Vector3();


        function init(myArr) {
				// PLY file
				/*
				var loader = new THREE.PLYLoader();
				loader.load( 'john3.ply', function ( geometry ) {
					geometry.computeFaceNormals();
					var material = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0x111111, shininess: 200, vertexColors: THREE.VertexColors} );
					//var material = new THREE.MeshStandardMaterial( {color: 0x0055ff, specular: 0x111111, shininess: 200 } );
					var mesh = new THREE.Mesh( geometry, material );
					mesh.scale.multiplyScalar( 4.38 );
					mesh.position.y = 3.5;
					mesh.rotation.x = -1.5;
					mesh.rotation.z = -0.5
					scene.add( mesh );
				});
				*/ 
				// Lights

				//scene.add( new THREE.HemisphereLight( 0x443333, 0x111122 ) );
				
			for (var i = 0; i<3; i++){
				var string =  "myAudio" + (i+1);
				var audio = document.getElementById(string);
				allAudio.push(audio); 
			}
			
			spherePlayHead = new THREE.Mesh( new THREE.SphereGeometry( 2, 16, 8 ), new THREE.MeshBasicMaterial( { color: 0x00eecf} ) );
			spherePlayHead.name = "spherePlayHead";


			currentlyBeingPlayed = undefined; 
			count = 0; 
            var i, n_sub, container;

            container = document.createElement('div');
            document.body.appendChild(container);

			isCameraMove = true; 
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
            cameraFollow = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1,1000);
            cameraFollow.position.x =0; 
            cameraFollow.position.y =0; 
            cameraFollow.position.z =50;
            cameraFollowHelper = new THREE.CameraHelper( cameraFollow );
            //cameraFollowHelper.visible = false;
            camera.position.z = 700;
			activeCamera = camera; 
			
            scene = new THREE.Scene();
            scene.add(cameraFollowHelper); 

			cameraRig = new THREE.Object3D();
			cameraRig.add( cameraFollow );
			scene.add(cameraRig); 
			
			// Lights

			scene.add( new THREE.HemisphereLight( 0xffffff, 0xffffff ) );

			
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);

            container.appendChild(renderer.domElement);


            // convert incoming flat list into a list of splines
            material = new THREE.MeshDepthMaterial( { overdraw: 0.5 } );

			parentTransform = new THREE.Object3D();
			console.log(myArr); 
            for (var j = 1; j < myArr.scribbles.length; j++) {
                var points = [];
                var rawArrayofPoints = myArr.scribbles[j].line;
                for (i = 0; i < rawArrayofPoints.length; i += 3) {
                    var threeVector = new THREE.Vector3(rawArrayofPoints[i], rawArrayofPoints[i + 1], rawArrayofPoints[i + 2])
                    points.push(threeVector);
                }

                var newSpline = new THREE.CatmullRomCurve3(points);
                //tube = new THREE.TubeGeometry(extrudePath, segments, 2, radiusSegments, closed2);
				tube = new THREE.TubeGeometry(newSpline, 200, 2, 4, false);

				tubeMesh = THREE.SceneUtils.createMultiMaterialObject( tube, [
				new THREE.MeshLambertMaterial({
					color: 0xff00ff
				}),
				new THREE.MeshBasicMaterial({
					color: 0x000000,
					opacity: 0.3,
					wireframe: true,
					transparent: true
				})]);

				parentTransform.add( tubeMesh );

                /*
                var geometry = new THREE.Geometry(),

                    //points = hilbert3D( new THREE.Vector3( 0,0,0 ), 200.0, 1, 0, 1, 2, 3, 4, 5, 6, 7 ),
                    colors = [],
                    colors2 = [],
                    colors3 = [];
				
				// resolutions
                n_sub = 9;
                var position, index;

                var spline = new THREE.Spline(points);

                for (i = 0; i < points.length * n_sub; i++) {

                    index = i / (points.length * n_sub);
                    position = spline.getPoint(index);

                    geometry.vertices[i] = new THREE.Vector3(position.x, position.y, position.z);

                    colors[i] = new THREE.Color(0xffff00);
                    //colors[i].setHSL(0.6,1.0,1.0);

                    colors2[i] = new THREE.Color(0xe9b8b8);
                    //colors2[i].setHSL(0.9, 1.0, Math.max(0, -position.y / 200) + 0.5);

                    colors3[i] = new THREE.Color(0xffffff, .3);
                    colors3[i].setHSL(i / (points.length * n_sub), 1.0, .9);
                }



                geometry.colors = colors2;


                // lines

                material = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    opacity: 1,
                    linewidth: 1,
                    vertexColors: THREE.VertexColors
                });

                var line, p, scale = 3,
                    d = 0;
                var parameters = [
                    [material, scale * 1.5, [d, 0, 0], geometry],

                ];

                console.log("param: " + parameters.length);
                for (i = 0; i < parameters.length; ++i) {

                    p = parameters[i];
                    line = new THREE.Line(p[3], p[0]);
                    line.scale.x = line.scale.y = line.scale.z = p[1];
                    line.position.x = p[2][0];
                    line.position.y = p[2][1];
                    line.position.z = p[2][2];
                    parentTransform.add(line);
                }
                */
            }
            
            parentTransform.rotation.x = -1.5;
			parentTransform.rotation.z = -.5;

            scene.add( parentTransform );

            raycaster = new THREE.Raycaster();
            raycaster.linePrecision = 5;

            stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.top = '0px';
            //container.appendChild(stats.domElement);


            document.addEventListener('mousemove', onDocumentMouseMove, false);
            document.addEventListener('touchstart', onDocumentTouchStart, false);
            document.addEventListener('touchmove', onDocumentTouchMove, false);
			document.addEventListener('mouseup', onDocumentMouseUp, false);
            //

            window.addEventListener('resize', onWindowResize, false);

        }

function removeEntity(object) {
    var selectedObject = scene.getObjectByName(object.name);
    scene.remove( selectedObject );
    animate();
}


        function onWindowResize() {

            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            
			cameraFollow.aspect = window.innerWidth / window.innerHeight;
            cameraFollow.updateProjectionMatrix();
            
            cameraFollowHelper.update();
			cameraFollowHelper.visible = false;
                    	
            
            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        //

        function onDocumentMouseMove(event) {
	console.log("something");
            mouseX = event.clientX - windowHalfX;
            mouseY = event.clientY - windowHalfY;
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        }

        function onDocumentTouchStart(event) {

            if (event.touches.length > 1) {

                event.preventDefault();

                mouseX = event.touches[0].pageX - windowHalfX;
                mouseY = event.touches[0].pageY - windowHalfY;
            }
        }

        function onDocumentTouchMove(event) {

            if (event.touches.length == 1) {

                event.preventDefault();
				console.log("Clicked?");
                mouseX = event.touches[0].pageX - windowHalfX;
                mouseY = event.touches[0].pageY - windowHalfY;
            }

        }
        
        
        function fadeColor ( line , time){
			stopSetInterval = setInterval(function(){ fadeColorHelper()}, 10);


        } 
        
       
        
        function moveColor(){
        	console.log("different now");
        	console.log(currentlyBeingPlayed);
        			var time = Date.now();
					var looptime = 20 * 1000;
					var t = ( time % looptime ) / looptime;

        	      if (time % looptime != 0){
        			
					var scale =1; 
		
					var pos = currentlyBeingPlayed.parameters.path.getPointAt( t );
					pos.multiplyScalar( scale );
		
					// interpolation
					var segments = currentlyBeingPlayed.tangents.length;
					var pickt = t * segments;
					var pick = Math.floor( pickt );
					var pickNext = ( pick + 1 ) % segments;
		
					binormal.subVectors( currentlyBeingPlayed.binormals[ pickNext ], tube.binormals[ pick 		] );
					binormal.multiplyScalar( pickt - pick ).add( currentlyBeingPlayed.binormals[ pick ] );
		
		
					var dir = currentlyBeingPlayed.parameters.path.getTangentAt( t );
		
					var offset = 15;
		
					normal.copy( binormal ).cross( dir );
		
					// We move on a offset on its binormal
					pos.add( normal.clone().multiplyScalar( offset ) );
		
					cameraFollow.position.copy( pos );
					//cameraEye.position.copy( pos );
		
		
					// Camera Orientation 1 - default look at
					// splineCamera.lookAt( lookAt );
		
					// Using arclength for stablization in look ahead.
					var lookAt = currentlyBeingPlayed.parameters.path.getPointAt( ( t + 30 / tube.		parameters.path.getLength() ) % 1 ).multiplyScalar( scale );
		
		
		
					// Camera Orientation 2 - up orientation via normal
					lookAt.copy( pos ).add( dir );
					cameraFollow.matrix.lookAt(cameraFollow.position, lookAt, normal);
					cameraFollow.rotation.setFromRotationMatrix( cameraFollow.matrix, cameraFollow.		rotation.order );

			//cameraHelper.update();

			//parent.rotation.y += ( targetRotation - parent.rotation.y ) * 0.05;
        			}
        			else{
        				isCameraMove = true; 
        				currentAudio.pause();
        				removeEntity(scaledCurrentlyBeingPlayed);
        				removeEntity(spherePlayHead);
        				
        				cameraFollowHelper.visible = false;
        				count = 0; 
        				currentlyBeingPlayed = undefined;
        				clearInterval(stopSetInterval); 
        				// this is the moment to animate the camera
        				
        			
        				var tween = new TWEEN.Tween(activeCamera.position).to({
    						x:0,
   						    y:0,
    						z:700
						},3000)
						.onComplete(function(){
							isLineFollowing = false; 
						}
						)
						.easing(TWEEN.Easing.Cubic.InOut);
						
						tween.start();
						
				
						var tweenW = new TWEEN.Tween(activeCamera.rotation).to({
    						x: 0,
   						    y: 0,
    						z: 0
						},3000)
						.easing(TWEEN.Easing.Cubic.InOut);
						
						
						tweenW.start();
						
						
						}


  			/*
        			console.log(currentlyBeingPlayed.scale);
        			
        			scaledCurrentlyBeingPlayed = currentlyBeingPlayed.clone();        			
        			scaledCurrentlyBeingPlayed.scale.x = 4; 
        			scaledCurrentlyBeingPlayed.scale.y = 4; 
        			scaledCurrentlyBeingPlayed.scale.z = 4; 
        			
        			scaledCurrentlyBeingPlayed.rotation.x = -1.5;
					scaledCurrentlyBeingPlayed.rotation.z = -.5;
					
					console.log(scaledCurrentlyBeingPlayed);
					scaledCurrentlyBeingPlayed.visible=false;
        			scene.add(scaledCurrentlyBeingPlayed);
        			
        			count++; 
        			var scaledPositionVector = scaledCurrentlyBeingPlayed.geometry.vertices[count].clone();
                    scaledPositionVector.applyMatrix4(scaledCurrentlyBeingPlayed.matrixWorld );
                    */

/*		


                    console.log("startNow!");      
                    console.log(scaledPositionVector);    		
        			var tweenf = new TWEEN.Tween(activeCamera.position).to({
    						x:scaledPositionVector.x,
   						    y:scaledPositionVector.y,
    						z:scaledPositionVector.z
						},3000)
						.easing(TWEEN.Easing.Cubic.InOut)
						.onComplete(function() {
							
						});
						
						tweenf.start();
						
					*/


		}

        				
        				
        				
        
        function onDocumentMouseUp(event) {
        console.log("clickzz");
        	if ( currentIntersected !== undefined ) {
        		console.log("click");
        		//currentIntersected.material.color = 0x0099FF;
        		console.log(currentIntersected);
        		//console.log(currentIntersected.geometry.colors);
        		//currentlyBeingPlayed, stopSetInterval
        		
        		
        		var count = 0; 
        		if(currentlyBeingPlayed == undefined){
        			
        			isLineFollowing = true; 
        			var hoverTxt = document.getElementById("hoverText"); 
					hoverTxt.style.display = "none"; 
					


        			isCameraMove = false; 
        			
        			currentlyBeingPlayed = currentIntersected.geometry;
      

                    console.log("yo!");
							scene.add(spherePlayHead);
        					activeCamera = cameraFollow;  
        					cameraFollowHelper.visible = true;
        					var rand = getRandomInt(0,3);
        					console.log(rand); 
        					currentAudio = allAudio[rand]; 
        					console.log(currentAudio); 
        					currentAudio.play();

        					stopSetInterval = setInterval(function(){ moveColor()}, 10);

        			
        		 }
        		
        	}
        }
        

        //

        function animate(time) {

            requestAnimationFrame(animate);
            render();
            
            TWEEN.update( time );

        }

        function render() {

		if(isCameraMove){
           camera.position.x += (mouseX - camera.position.x) * .05;
           camera.position.y += (-mouseY + 200 - camera.position.y) * .05;
           camera.lookAt(scene.position);
            
           activeCamera.position.x += (mouseX - camera.position.x) * .05;
           activeCamera.position.y += (-mouseY + 200 - camera.position.y) * .05;
           activeCamera.lookAt(scene.position);
            }

/// begin selection
			if (!isLineFollowing){

            raycaster.setFromCamera(mouse, activeCamera);

            var intersects = raycaster.intersectObjects( parentTransform.children , true);

            if ( intersects.length > 0 ) {
					
					if ( currentIntersected !== undefined ) {

						currentIntersected.material.linewidth = 1;
						

					}

					currentIntersected = intersects[ 0 ].object;
					currentIntersected.material.linewidth = 10; 

					//sphereInter.visible = true;
					//sphereInter.position.copy( intersects[ 0 ].point );

				} 
				else {
					if ( currentIntersected !== undefined ) {

						currentIntersected.material.linewidth = 1;

					}
					currentIntersected = undefined;
				}
			
			
			// toggle hover text
			var hoverTxt = document.getElementById("hoverText"); 
			if(currentIntersected !== undefined ){
				hoverTxt.style.display = "block"; 
				hoverTxt.innerHTML = currentIntersected.id; 
				console.log(currentIntersected.id);
			}
			else{
				hoverTxt.style.display = "none"; 
			}
			}
		
		//end selection 
            renderer.setClearColor(0xffffff, 1);
            renderer.render(scene, activeCamera);

        }
        
        function getRandomInt(min, max) {
  			return Math.floor(Math.random() * (max - min)) + min;
		}
		
		
    </script>
</body>

</html>